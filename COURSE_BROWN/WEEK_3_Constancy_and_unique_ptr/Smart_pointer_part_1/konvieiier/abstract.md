Я считаю эту задачу крайне сложной и непонятной. Это связано с тем, что во-первых ее условие сложно понять и во-вторых она сама по себе трудная. На мой взгляд, к ней нужно добавить разнообразные пояснения и подсказки. Далее я напишу те подсказки, которые помогли мне понять условие и сдать задачу.

Термин "обработчики" - это классы Reader, Filter, Copier, Sender, наследники абстрактного класса Worker

В описании класса Worker есть фраза "метод PassOn должен вызывать метод Process следующего обработчика, если он был установлен". Во-первых, возникает вопрос, как же определить следующий обработчик, имея только один текущий, например, Reader? Оказывается, надо завести в классе Worker специальное поле, которое для всех экземпляров кроме последнего будет указывать на следующий обработчик. То есть по сути надо вручную построить односвязный список, и именно этот список в задаче понимается под "цепочкой обработчиков". Во-вторых, слова "если он был установлен" означают, что этот указатель корректно инициализирован.

"Передать email дальше" означает, что надо вызвать метод PassOn, использовав перемещение уникального указателя на объект Email (так как скопировать unique_ptr нельзя). Данная операция встречается в двух методах: Run (только для Reader) и Process (для всех обработчиков).

Мне была совершенно непонятна фраза "метод Process <класса Copier> должен передавать сообщение как исходному получателю, так и указанному в конструкторе.". Недоразумение вызвали термины "исходный получатель" и "указанный в конструкторе получатель". Из объявления метода видно, что у него есть ровно один email - тот, который передали как аргумент, и передать его он его может ровно одному обработчику - тому, который следует за ним в односвязном списке. Оказывается, здесь имелось в виду, что надо сравнить поле to email-а из аргумента и ту строку, которая была задана в конструкторе класса Copier. И если они разные, надо создать второй email, у которого получатель будет как в конструкторе, а остальные поля как в первом email-е. И после этого оба email-а надо передать следующему обработчику методом PassOn.

В условии сказано, что "Метод Build должен возвращать готовую цепочку обработчиков", но на самом деле он возвращает уникальный указатель на начало цепочки.

По поводу функции make_unique<T>:

Один вызов этой функции создает и объект типа T, и умный указатель на него. Причем важно знать синтаксис, который при этом используется.

Пример 1. Вам нужно создать объект класса Reader, и у вас уже есть конструктор, принимающий istream& in. Тогда аргументы конструктора можно писать прямо в круглых скобках:

make_unique<Reader>(in)

Пример 2. Вам нужно создать объект типа Email, который является структурой с тремя публичными полями. По умолчанию компилятор позволяет инициализировать эти поля тремя значениями, даже без написания специального конструктора. То есть на первый взгляд, можно написать так:

make_unique<Email>(from, to, body)

Однако так программа не скомпилируется, я не знаю, почему. Если бы вы просто создавали объект типа Email, то перечислить три аргумента в круглых скобках можно. А если создается еще и умный указатель на этот объект, то уже нельзя. Правильно написать так:

make_unique<Email>(Email({ from, to, body })))


Не совсем согласен с некоторыми моментами Ваших замечаний. Вся сложность задачи как раз и сводится к тому, чтобы понять предложенный паттерн, при этом большинство дополнительных технических деталей, связанных с умными указателями были предложены в материалах для самостоятельного изучения. Лично мое мнение: задача -- одна из лучших на текущий момент, которые предлагались для решения на этих курсах. Ее формат немного нестандартен, но этим она и цепляет, заставляет думать не только по поводу технических деталей, но и архитектурных приемов. Но давайте по существу.

* "Метод Build должен возвращать готовую цепочку обработчиков"

Если элемент, содержит ссылку на следующий элемент, то у нас уже готов порядок для цепочки. Один из способов ее задания -- ссылка на первый элемент, порядок и конечный элемент (В данном случае задается условием на отсутствие следующего). Таким образом, например, устроен контейнер лист.

* Пример 2. Вам нужно создать объект типа Email, который является структурой с тремя публичными полями.

Как раз таки, в данном случае вы можете писать make_unique<Email>(from, to, body), но для этого Вам явно нужно определить конструктор, который будет вызываться Email(string from_, string to_, string body_). В предложенном Вами варианте будет вызываться конструктор копирования, что вообще врядли уместно в этом контексте.

http://cpp-reference.ru/patterns/behavioral-patterns/chain-of-responsibility/
