## unordered_set<unique_ptr>
Ранее мы с вами разбирали, как для решения задачи ObjectPool использовать контейнер set с элементами типа unique_ptr. Однако, выбор этого контейнера кажется не совсем верным, т.к. set - упорядоченный контейнер, а отношение порядка для указателей особого смысла не имеет. И мы уже знаем, что в подобных случаях эффективнее использовать неупорядоченные контейнеры.

В этом материале мы разберёмся, как использовать для этой задачи контейнер unordered_set.

Посмотрим, что нам нужно изменить относительно реализации, использующей контейнер set, которая была описана в начале блока. Для начала объявим поле allocated как unordered_set<unique_ptr<T>>. В методе Allocate() при этом не придётся делать никаких изменений.
```c++
template <typename T>
void ObjectPool<T>::Deallocate(T* object) {
  auto it = allocated.find(object);
  if (it == allocated.end()) {
    throw invalid_argument("");
  }
  free.push(move(allocated.extract(it).value()));
}
```
Проблема опять в том, что метод find() отказывается принимать сырой указатель. Давайте посмотрим документацию метода find() контейнера unordered_set:
```c++
iterator find(const Key& key);                            // (1)
const_iterator find(const Key& key) const;                // (2)
```
Как видим, здесь у нас вообще нет каких-либо перегрузок, кроме тех, что принимают const Key& (в нашем случае это будет const unique_ptr<T>&). На самом деле это логично. unordered_set, в отличие от set, сравнивает не объекты, а их хэши. Сравнивать хэш unique_ptr с хэшом какого-то другого типа не имеет смысла.

Что ж, раз так, нам не остаётся другого выхода, кроме как создать некоторый unique_ptr, который мы будем искать. Создать его будет не сложно. У нас же есть конструктор, который принимает сырой указатель:
```c++
unique_ptr<T> ptr(object);
```
На лекции мы, правда, только что узнали, что использование такого конструктора противоречит соглашениям по владению динамическими объектами. Но в данном случае у нас нет выхода. Нам необходимо создать unique_ptr. Поэтому мы сознательно отступаем от соглашений.

Теперь мы можем вызвать метод find(), передав ему unique_ptr вместо сырого указателя:
```c++
auto it = allocated.find(ptr);  // Раньше передавали object
```
И это будет работать. Указатель действительно будет искаться в нашем множестве. Но, как вы, вероятно, уже догадались, будет проблема. Наш ptr будет удалён при выходе из функции. И в своём деструкторе он, как честный unique_ptr, удалит объект, на который ссылается. А это явно не входило в наши планы.

Мы уже знаем, что unique_ptr удаляет объект, поскольку он владеет им. Нам же с вами нужно создать что-то вроде "невладеющего" unique_ptr. Прямо так в С++ сделать нельзя (к слову, для shared_ptr это сделать можно, и в последней лекции курса мы узнаем как). Но зато можно отозвать владение у unique_ptr. Для этого он предоставляет метод release(). Этот метод возвращает сырой указатель, которым владел unique_ptr, а сам unique_ptr при этом обнуляется. Объект же не удаляется, и владение им передаётся вызывающей стороне.

Используя метод release(), мы можем правильным образом сделать поиск объекта в исправленной версии Deallocate():
```c++
unique_ptr<T> ptr(object);  // Создаём временный unique_ptr
auto it = allocated.find(ptr);  // Ищем его в множестве
ptr.release();  // Отзываем владение
```
Вот такой интересный финт, который иногда может быть полезен. Мы создали unique_ptr не потому, что нам нужно было управлять динамической памятью, а просто потому, что нам нужен был сам unique_ptr. Чтобы посчитать его хэш.

Обратите внимание, что метод release() по определению нарушает соглашения по владению динамическими объектами. В соответствии с соглашениями, unique_ptr владеет объектом. А тут раз, и он внезапно перестаёт владеть объектом. Но в данном случае мы использовали release(), т.к. уже определились, что нам приходится отступать от соглашений, ничего не поделаешь.

Теперь вспомним, что нам больше не нужны функции для сравнения unique_ptr с сырым указателем, и напишем полную реализацию класса ObjectPool с использованием контейнера unordered_set (комментарии указывают разницу с реализацией на set):

```c++
template <class T>
class ObjectPool {
public:
  T* Allocate();
  T* TryAllocate();

  void Deallocate(T* object);

private:
  queue<unique_ptr<T>> free;
  unordered_set<unique_ptr<T>> allocated;  // Изменили на unordered_set
};

template <typename T>
T* ObjectPool<T>::Allocate() {
  if (free.empty()) {
    free.push(make_unique<T>());
  }
  auto ptr = move(free.front());
  free.pop();
  T* ret = ptr.get();
  allocated.insert(move(ptr));
  return ret;
}

template <typename T>
T* ObjectPool<T>::TryAllocate() {
  if (free.empty()) {
    return nullptr;
  }
  return Allocate();
}

// Убрали функции сравнения, они больше не нужны

template <typename T>
void ObjectPool<T>::Deallocate(T* object) {
  // Добавили создание временного unique_ptr
  unique_ptr<T> ptr(object);
  auto it = allocated.find(ptr);
  ptr.release();
  if (it == allocated.end()) {
    throw invalid_argument("");
  }
  free.push(move(allocated.extract(it).value()));
}
```
Опять же видим, что изменения минимальны. Главное отличие в том, как нам пришлось отступить от соглашений по владению динамическими объектами.

Однако заметим, что отступление от соглашений может быть чревато. Действительно, если во время работы метода find() возникнет исключение, то ptr.release() не будет вызван, и переданный объект будет удалён в деструкторе ptr. Что в дальнейшем приведёт к ошибке в результате двойного удаления, ведь у объекта где-то есть реальный владелец, который попытается его удалить. Ну и в целом, удалять объект, переданный по сырому указателю, который, как мы помним, является невладеющим - прямой и точный выстрел себе в ногу.

На практике, конечно, крайне маловероятно, что метод find() бросит исключение. Тем не менее, есть возможность сделать решение надёжным на 100% и предусмотреть даже такой экзотический случай. Для этого нам понадобится техника RAII, о которой мы расскажем в следующем блоке.

Реализация конкретного решения этой проблемы с помощью техники RAII остаётся упражнением для самостоятельного выполнения.
